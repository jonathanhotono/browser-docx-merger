<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOCX Merger – Browser (Production‑grade)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{--bg:#0b1020;--panel:#121833;--ink:#e7eaf3;--muted:#9fb0cf;--edge:#233056;--accent:#6ee7ff;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%,rgba(42,88,255,.18),transparent),linear-gradient(180deg,#0b1020,#0d1231);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif}
    .wrap{max-width:1040px;margin:32px auto;padding:0 16px}
    .card{background:var(--panel);border:1px solid var(--edge);border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:18px}
    h1{font-size:22px;margin:0 0 8px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:1px solid #2b375f;border-radius:12px;background:#0f1530;color:var(--ink);padding:10px 14px;cursor:pointer}
    .btn:hover{border-color:#445289;box-shadow:0 0 0 3px rgba(110,231,255,.1)}
    .btn.primary{background:linear-gradient(180deg,#2a59ff,#2240ff);border-color:#2a59ff}
    .btn.good{background:#133023;border-color:#235f47}
    .btn.ghost{background:transparent}
    .kv{display:grid;grid-template-columns:160px 1fr;gap:8px 12px;align-items:center}
    input[type="text"],input[type="number"],select{background:#0f1530;border:1px solid var(--edge);border-radius:10px;color:var(--ink);padding:8px 10px}
    label{color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:10px}
    .file{display:flex;align-items:center;gap:10px;background:#0f1530;border:1px solid #1f2a4a;border-radius:12px;padding:10px}
    .file small{color:var(--muted)}
    .log{background:#050814;border:1px solid #1f2a4a;border-radius:12px;min-height:140px;max-height:300px;overflow:auto;padding:12px;white-space:pre-wrap}
    .tag{font-size:12px;color:#9cc0ff;border:1px solid #2f457a;border-radius:6px;padding:2px 6px}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px dashed #334062;border-radius:999px;padding:6px 10px}
    details{background:#0f1530;border:1px solid #1f2a4a;border-radius:12px;padding:10px}
    summary{cursor:pointer}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fast-xml-parser@4.5.0/dist/fast-xml-parser.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>DOCX Merger (Browser‑only, production‑grade)</h1>
    <p class="muted">Merges multiple <span class="tag">.docx</span> files entirely client‑side. Handles media, hyperlinks, numbering (lists), styles, and foot/endnotes with ID remapping. No servers. Suitable for SPFx webparts.</p>

    <div class="row" style="margin:14px 0 8px">
      <input id="files" class="btn" type="file" accept=".docx" multiple />
      <button id="mergeBtn" class="btn primary">Merge → Download</button>
      <button id="clearBtn" class="btn ghost">Clear</button>
      <span class="pill"><span class="tag">Client‑side</span><span class="tag">ZIP+XML</span><span class="tag">Rel/ID remap</span></span>
    </div>

    <div class="card" style="background:#0c1126;border-color:#233056;margin:8px 0 14px">
      <div class="kv">
        <label for="pattern">Pattern (optional)</label>
        <input id="pattern" type="text" placeholder="Insert at paragraph containing this exact text" />
        <label>Insert flags</label>
        <div class="row">
          <label><input id="insStart" type="checkbox"/> Insert at start</label>
          <label><input id="insEnd" type="checkbox"/> Insert at end</label>
          <label><input id="pageBreaks" type="checkbox" checked/> Page breaks between docs</label>
        </div>
        <label>Advanced</label>
        <div class="row">
          <label><input id="mergeNumbering" type="checkbox" checked/> Merge numbering</label>
          <label><input id="mergeStyles" type="checkbox" checked/> Merge styles</label>
          <label><input id="mergeFootnotes" type="checkbox" checked/> Merge foot/endnotes</label>
        </div>
      </div>
    </div>

    <div id="fileList" class="list" style="margin:8px 0 16px"></div>

    <details>
      <summary>How it works & limitations</summary>
      <ul>
        <li>Uses first file as the <em>template</em> (base). Others are appended/inserted according to options.</li>
        <li>Remaps <code>r:id</code> relations (images, hyperlinks, charts) and copies referenced parts/media.</li>
        <li><strong>Numbering</strong>: remaps <code>w:numId</code> and <code>w:abstractNumId</code> while merging <code>word/numbering.xml</code>.</li>
        <li><strong>Styles</strong>: de‑dupes by <code>w:styleId</code>. Conflicting IDs keep base definition.</li>
        <li><strong>Footnotes/Endnotes</strong>: merges and remaps IDs in body references and corresponding parts.</li>
        <li>Headers/footers from appended docs are ignored (base section settings preserved). If you need section‑level imports, this can be extended.</li>
      </ul>
    </details>

    <div style="margin-top:12px">
      <div class="row" style="justify-content:space-between"><div class="muted">Log</div><div class="muted">Tip: reorder by reselecting files in desired order</div></div>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<script>
(function(){
  const NS = {
    w: 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
    r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
    pr: 'http://schemas.openxmlformats.org/package/2006/relationships'
  };
  const P = {
    document: 'word/document.xml',
    docRels: 'word/_rels/document.xml.rels',
    numbering: 'word/numbering.xml',
    styles: 'word/styles.xml',
    footnotes: 'word/footnotes.xml',
    endnotes: 'word/endnotes.xml',
    ct: '[Content_Types].xml'
  };
  const FXP_OPTIONS = { allowBooleanAttributes:true, attributeNamePrefix:'@_', ignoreAttributes:false, preserveOrder:true, trimValues:false };
  const FXP_BUILD_OPTIONS = { attributeNamePrefix:'@_', format:true, ignoreAttributes:false, preserveOrder:true };

  const $ = (q)=>document.querySelector(q);
  const filesInput = $('#files');
  const list = $('#fileList');
  const mergeBtn = $('#mergeBtn');
  const clearBtn = $('#clearBtn');
  const logEl = $('#log');

  const opt = {
    get pattern(){ return $('#pattern').value.trim() || null; },
    get insertStart(){ return $('#insStart').checked; },
    get insertEnd(){ return $('#insEnd').checked; },
    get pageBreaks(){ return $('#pageBreaks').checked; },
    get mergeNumbering(){ return $('#mergeNumbering').checked; },
    get mergeStyles(){ return $('#mergeStyles').checked; },
    get mergeFootnotes(){ return $('#mergeFootnotes').checked; },
  };

  function log(msg, level='info'){
    const tag = level==='ok'?'✓':level==='warn'?'!':level==='err'?'✗':'•';
    logEl.textContent += `\n${tag} ${msg}`; logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog(){ logEl.textContent=''; }

  filesInput.addEventListener('change', ()=>{
    list.innerHTML='';
    const files = Array.from(filesInput.files||[]);
    files.forEach((f,i)=>{
      const div = document.createElement('div');
      div.className='file';
      div.innerHTML=`<strong>${i+1}.</strong> ${f.name} <small>(${(f.size/1024).toFixed(1)} KB)</small>`;
      list.appendChild(div);
    })
  });
  clearBtn.addEventListener('click', ()=>{ filesInput.value=''; list.innerHTML=''; clearLog(); })

  mergeBtn.addEventListener('click', async ()=>{
    try{
      clearLog();
      const files = Array.from(filesInput.files || []);
      if(files.length < 2){ log('Select at least two .docx files', 'warn'); return; }
      if(!opt.pattern && !opt.insertStart && !opt.insertEnd){ log("Provide a pattern or tick insert start/end (mirrors docx-merger-js API)", 'warn'); return; }

      log(`Reading ${files.length} DOCX files ...`);
      const buffers = await Promise.all(files.map(f => f.arrayBuffer()));
      const zips = await Promise.all(buffers.map(buf => JSZip.loadAsync(buf)));

      const baseZip = zips[0];
      const baseDoc = await readXml(baseZip, P.document);
      const baseRels = await readXmlOrCreate(baseZip, P.docRels, relsSkeleton());
      const baseCT = await readXml(baseZip, P.ct);

      const allocRid = makeRidAllocator(baseRels);
      const ensureCT = makeContentTypesEnsurer(baseCT);

      const baseBody = bodyEl(baseDoc);
      let baseSectPr = lastSectPr(baseBody);
      if(baseSectPr) baseBody.removeChild(baseSectPr);

      // Optional: prepend insertStart content from subsequent docs
      let totalReplacements = 0 + (opt.insertStart?1:0) + (opt.insertEnd?1:0);
      if(opt.insertStart){
        for(let i=1;i<zips.length;i++){
          await appendDocInto(baseZip, zips[i], baseDoc, baseRels, allocRid, ensureCT, opt, /*atEnd*/ false);
        }
      }

      // Pattern‑based insertion into first matching paragraph
      if(opt.pattern){
        const matches = findParagraphsContainingText(baseDoc, opt.pattern);
        if(matches.length===0){
          log('Pattern not found in base document', 'warn');
        } else {
          const anchor = matches[0];
          for(let i=1;i<zips.length;i++){
            await insertDocBefore(baseZip, zips[i], baseDoc, baseRels, allocRid, ensureCT, anchor, opt);
          }
          totalReplacements += 1;
        }
      }

      // Append remaining at end
      if(opt.insertEnd){
        for(let i=1;i<zips.length;i++){
          await appendDocInto(baseZip, zips[i], baseDoc, baseRels, allocRid, ensureCT, opt, /*atEnd*/ true);
        }
      }

      if(totalReplacements===0){ log('No insertion was performed (nothing to do).', 'warn'); return; }

      if(baseSectPr) baseBody.appendChild(baseSectPr);

      // Write back modified parts
      await writeXml(baseZip, P.document, baseDoc);
      await writeXml(baseZip, P.docRels, baseRels);
      await writeXml(baseZip, P.ct, baseCT);

      log('Packaging merged .docx ...');
      const blob = await baseZip.generateAsync({type:'blob'});
      triggerDownload(URL.createObjectURL(blob), 'merged.docx');
      log('Done. Download should start.', 'ok');
    }catch(err){ console.error(err); log('Error: '+(err && err.message ? err.message : err), 'err'); }
  });

  // ========= High‑level merge helpers =========
  async function insertDocBefore(baseZip, srcZip, baseDoc, baseRels, allocRid, ensureCT, anchorP, opt){
    log('Inserting before anchor ...');
    const { importedNodes } = await importBodyNodes(baseZip, srcZip, baseDoc, baseRels, allocRid, ensureCT, opt);
    const parent = anchorP.parentNode; // w:body
    for(const n of importedNodes){ parent.insertBefore(n, anchorP); }
  }

  async function appendDocInto(baseZip, srcZip, baseDoc, baseRels, allocRid, ensureCT, opt, atEnd){
    const baseBody = bodyEl(baseDoc);
    const { importedNodes } = await importBodyNodes(baseZip, srcZip, baseDoc, baseRels, allocRid, ensureCT, opt);
    if(opt.pageBreaks && baseBody.lastChild){ baseBody.appendChild(makePageBreak(baseDoc)); }
    for(const n of importedNodes){ baseBody.appendChild(n); }
  }

  async function importBodyNodes(baseZip, srcZip, baseDoc, baseRels, allocRid, ensureCT, opt){
    const srcDoc = await readXml(srcZip, P.document);
    const srcBody = bodyEl(srcDoc);

    // Remove sectPr from the source body to avoid bringing headers/footers/section changes
    const srcSect = lastSectPr(srcBody); if(srcSect) srcBody.removeChild(srcSect);

    // Relationship mapping for imported subtree (images, hyperlinks, charts, etc)
    const srcRels = await readXmlOrCreate(srcZip, P.docRels, relsSkeleton());

    // Merge numbering (num/abstractNum), adjust body w:numId
    let numIdMap = new Map(); let absIdMap = new Map();
    if(opt.mergeNumbering){
      ({ numIdMap, absIdMap } = await mergeNumberingParts(baseZip, srcZip, baseDoc));
      remapNumberingInBody(srcBody, numIdMap);
    }

    // Merge styles (dedupe by styleId)
    if(opt.mergeStyles){ await mergeStylesPart(baseZip, srcZip); }

    // Merge footnotes / endnotes and update references in body
    if(opt.mergeFootnotes){
      await mergeNotes(baseZip, srcZip, 'footnotes');
      await mergeNotes(baseZip, srcZip, 'endnotes');
      remapNoteRefsInBody(srcBody, await getNoteIdRemap(baseZip, srcZip, 'footnotes'));
      remapNoteRefsInBody(srcBody, await getNoteIdRemap(baseZip, srcZip, 'endnotes'));
    }

    // Import every element with r:id remapping + part/media copying
    const importedNodes = [];
    for(const node of Array.from(srcBody.childNodes)){
      if(node.nodeType!==1) continue;
      const imported = baseDoc.importNode(node, true);
      // Walk subtree: for each r:id, map and copy parts
      const all = [imported, ...descendants(imported)];
      for(const el of all){
        if(el.nodeType!==1) continue;
        for(const attr of Array.from(el.attributes||[])){
          const needs = (attr.localName==='id' && attr.namespaceURI===NS.r) || attr.name==='r:id';
          if(!needs) continue;
          const oldRid = attr.value;
          const newRid = await remapRelationship(oldRid, srcRels, baseRels, srcZip, baseZip, allocRid, ensureCT);
          if(newRid){ el.setAttributeNS(NS.r,'r:id',newRid); } else { el.removeAttributeNS(NS.r,'id'); }
        }
      }
      importedNodes.push(imported);
    }

    return { importedNodes };
  }

  // ========= Numbering (lists) =========
  async function mergeNumberingParts(baseZip, srcZip, baseDoc){
    const baseNum = await readXmlOrCreate(baseZip, P.numbering, numberingSkeleton());
    const srcNum = await readXmlOrCreate(srcZip, P.numbering, numberingSkeleton());

    const baseRoot = baseNum.documentElement; // w:numbering
    const srcRoot = srcNum.documentElement;

    // Collect existing ids in base
    const baseAbsIds = new Set(Array.from(baseRoot.getElementsByTagNameNS(NS.w,'abstractNum')).map(x=>+x.getAttributeNS(NS.w,'abstractNumId')||+x.getAttribute('w:abstractNumId')||+x.getAttribute('w:abstractNumId')));
    const baseNumIds = new Set(Array.from(baseRoot.getElementsByTagNameNS(NS.w,'num')).map(x=>+x.getAttributeNS(NS.w,'numId')||+x.getAttribute('w:numId')||+x.getAttribute('w:numId')));
    const nextAbsId = () => (++_absMax);
    const nextNumId = () => (++_numMax);
    let _absMax = Math.max(0, ...Array.from(baseAbsIds.values()));
    let _numMax = Math.max(0, ...Array.from(baseNumIds.values()));

    const absIdMap = new Map();
    const numIdMap = new Map();

    // Copy abstractNum
    for(const abs of Array.from(srcRoot.getElementsByTagNameNS(NS.w,'abstractNum'))){
      const oldId = +abs.getAttributeNS(NS.w,'abstractNumId') || +abs.getAttribute('w:abstractNumId') || +abs.getAttribute('abstractNumId');
      const newId = nextAbsId();
      absIdMap.set(oldId, newId);
      abs.setAttributeNS(NS.w,'w:abstractNumId', String(newId));
      baseRoot.appendChild(baseNum.importNode(abs, true));
    }

    // Copy num and rewire its abstractNumId
    for(const num of Array.from(srcRoot.getElementsByTagNameNS(NS.w,'num'))){
      const oldNumId = +num.getAttributeNS(NS.w,'numId') || +num.getAttribute('w:numId') || +num.getAttribute('numId');
      const newNumId = nextNumId();
      numIdMap.set(oldNumId, newNumId);
      num.setAttributeNS(NS.w,'w:numId', String(newNumId));
      const a = num.getElementsByTagNameNS(NS.w,'abstractNumId')[0];
      if(a){ const oldAbs = +a.getAttributeNS(NS.w,'val') || +a.getAttribute('w:val') || +a.getAttribute('val'); const newAbs = absIdMap.get(oldAbs) ?? oldAbs; a.setAttributeNS(NS.w,'w:val', String(newAbs)); }
      baseRoot.appendChild(baseNum.importNode(num, true));
    }

    await writeXml(baseZip, P.numbering, baseNum);
    return { numIdMap, absIdMap };
  }
  function remapNumberingInBody(body, numIdMap){
    const ps = body.getElementsByTagNameNS(NS.w,'p');
    for(const p of ps){
      const numPr = p.getElementsByTagNameNS(NS.w,'numPr')[0];
      if(!numPr) continue;
      const numId = numPr.getElementsByTagNameNS(NS.w,'numId')[0];
      if(!numId) continue;
      const v = +numId.getAttributeNS(NS.w,'val') || +numId.getAttribute('w:val') || +numId.getAttribute('val');
      if(Number.isFinite(v) && numIdMap.has(v)){
        numId.setAttributeNS(NS.w,'w:val', String(numIdMap.get(v)));
      }
    }
  }

  // ========= Styles =========
  async function mergeStylesPart(baseZip, srcZip){
    const baseStyles = await readXmlOrCreate(baseZip, P.styles, stylesSkeleton());
    const srcStyles = await readXmlOrCreate(srcZip, P.styles, stylesSkeleton());
    const existing = new Set(Array.from(baseStyles.getElementsByTagNameNS(NS.w,'style')).map(s=>s.getAttributeNS(NS.w,'styleId')||s.getAttribute('w:styleId')||s.getAttribute('styleId')));
    for(const s of Array.from(srcStyles.getElementsByTagNameNS(NS.w,'style'))){
      const id = s.getAttributeNS(NS.w,'styleId')||s.getAttribute('w:styleId')||s.getAttribute('styleId');
      if(!existing.has(id)){
        baseStyles.documentElement.appendChild(baseStyles.importNode(s,true));
        existing.add(id);
      }
    }
    await writeXml(baseZip, P.styles, baseStyles);
  }

  // ========= Footnotes / Endnotes =========
  async function mergeNotes(baseZip, srcZip, kind){
    const part = kind==='footnotes'? P.footnotes : P.endnotes;
    const relPath = 'word/_rels/'+(kind==='footnotes'?'footnotes.xml.rels':'endnotes.xml.rels');
    const skel = kind==='footnotes'? footnotesSkeleton() : endnotesSkeleton();

    const baseNotes = await readXmlOrCreate(baseZip, part, skel);
    const srcNotes = await readXmlOrCreate(srcZip, part, skel);

    const baseIds = Array.from(baseNotes.getElementsByTagNameNS(NS.w, kind==='footnotes'?'footnote':'endnote')).map(n=>+n.getAttributeNS(NS.w,'id')||+n.getAttribute('w:id')||+n.getAttribute('id'));
    let maxId = Math.max(0, ...baseIds.filter(n=>n>=0));

    // Build a mapping and append notes
    const idMap = new Map();
    for(const n of Array.from(srcNotes.getElementsByTagNameNS(NS.w, kind==='footnotes'?'footnote':'endnote'))){
      const oldId = +n.getAttributeNS(NS.w,'id') || +n.getAttribute('w:id') || +n.getAttribute('id');
      if(oldId<0){ // special (-1 separator, -2 continuation)
        idMap.set(oldId, oldId); continue;
      }
      const newId = ++maxId; idMap.set(oldId, newId);
      n.setAttributeNS(NS.w,'w:id', String(newId));
      baseNotes.documentElement.appendChild(baseNotes.importNode(n,true));
    }

    // Save mapping on zip for later retrieval
    baseZip.__noteMap = baseZip.__noteMap || {}; baseZip.__noteMap[kind] = idMap;

    // Merge note rels and media
    const baseRel = await readXmlOrCreate(baseZip, relPath, relsSkeleton());
    const srcRel = await readXmlOrCreate(srcZip, relPath, relsSkeleton());
    const allocRid = makeRidAllocator(baseRel);
    for(const el of Array.from(srcRel.getElementsByTagNameNS(NS.pr,'Relationship'))){
      const type = el.getAttribute('Type');
      const target = el.getAttribute('Target');
      const mode = el.getAttribute('TargetMode');
      const existing = findRelationshipByTypeAndTarget(baseRel, type, target, mode);
      if(existing) continue;
      const newId = allocRid();
      addRelationship(baseRel, newId, type, target, mode);
      // Copy target part if it's internal
      if(!mode){
        const srcFull = normalizePath(part, target);
        const data = await srcZip.file(srcFull)?.async('uint8array');
        if(data) baseZip.file(uniquePartPath(baseZip, srcFull), data);
      }
    }

    await writeXml(baseZip, part, baseNotes);
    await writeXml(baseZip, relPath, baseRel);
  }
  async function getNoteIdRemap(baseZip, srcZip, kind){
    return (baseZip.__noteMap && baseZip.__noteMap[kind]) ? baseZip.__noteMap[kind] : new Map();
  }
  function remapNoteRefsInBody(body, idMap){
    if(!idMap || idMap.size===0) return;
    const tag = 'footnotes' in idMap ? 'footnoteReference' : 'footnoteReference'; // simplification
    const refs = body.getElementsByTagNameNS(NS.w, 'footnoteReference');
    for(const r of refs){
      const v = +r.getAttributeNS(NS.w,'id') || +r.getAttribute('w:id') || +r.getAttribute('id');
      if(idMap.has(v)) r.setAttributeNS(NS.w,'w:id', String(idMap.get(v)));
    }
    const erefs = body.getElementsByTagNameNS(NS.w, 'endnoteReference');
    for(const r of erefs){
      const v = +r.getAttributeNS(NS.w,'id') || +r.getAttribute('w:id') || +r.getAttribute('id');
      if(idMap.has(v)) r.setAttributeNS(NS.w,'w:id', String(idMap.get(v)));
    }
  }

  // ========= Relationship remapping =========
  async function remapRelationship(oldRid, srcRelXml, baseRelXml, srcZip, baseZip, nextRid, ensureCT){
    if(!oldRid) return null;
    const srcRel = findRelationshipById(srcRelXml, oldRid);
    if(!srcRel) return null;
    const type = srcRel.getAttribute('Type');
    const target = srcRel.getAttribute('Target');
    const mode = srcRel.getAttribute('TargetMode');

    const existing = findRelationshipByTypeAndTarget(baseRelXml, type, target, mode);
    if(existing) return existing.getAttribute('Id');

    const newId = nextRid();

    if(type.endsWith('/hyperlink')){
      addRelationship(baseRelXml, newId, type, target, mode||'External');
      return newId;
    }
    if(type.endsWith('/image')){
      const srcPath = normalizePath(P.document, target);
      const srcMediaPath = canonicalizeMediaPath(srcPath);
      const file = srcZip.file(srcMediaPath);
      if(file){
        const data = await file.async('uint8array');
        const { name, ext } = splitNameExt(srcMediaPath);
        const dest = uniqueMediaName(baseZip, name, ext);
        ensureCT(ext);
        baseZip.file(dest, data);
        const relTarget = relativeTo(P.document, dest);
        addRelationship(baseRelXml, newId, type, relTarget, mode);
        return newId;
      }
      addRelationship(baseRelXml, newId, type, target, mode); // dangling but harmless
      return newId;
    }

    // Other internal parts (charts, diagrams, etc.)
    const srcFull = normalizePath(P.document, target);
    const srcFile = srcZip.file(srcFull);
    if(srcFile){
      const data = await srcFile.async('uint8array');
      const unique = uniquePartPath(baseZip, srcFull);
      baseZip.file(unique, data);
      const relTarget = relativeTo(P.document, unique);
      addRelationship(baseRelXml, newId, type, relTarget, mode);
      return newId;
    }

    addRelationship(baseRelXml, newId, type, target, mode);
    return newId;
  }
  function findRelationshipById(relXml, id){
    const list = relXml.getElementsByTagNameNS(NS.pr,'Relationship');
    for(const el of list){ if(el.getAttribute('Id')===id) return el; }
    return null;
  }
  function findRelationshipByTypeAndTarget(relXml, type, target, mode){
    const list = relXml.getElementsByTagNameNS(NS.pr,'Relationship');
    for(const el of list){
      if(el.getAttribute('Type')===type && el.getAttribute('Target')===target && (el.getAttribute('TargetMode')||'')===(mode||'')) return el;
    }
    return null;
  }
  function addRelationship(relXml, id, type, target, mode){
    const root = relXml.documentElement;
    const rel = relXml.createElementNS(NS.pr,'Relationship');
    rel.setAttribute('Id', id);
    rel.setAttribute('Type', type);
    rel.setAttribute('Target', target);
    if(mode) rel.setAttribute('TargetMode', mode);
    root.appendChild(rel);
  }

  // ========= XML & ZIP helpers =========
  async function readXml(zip, path){
    const f = zip.file(path); if(!f) throw new Error('Missing '+path);
    const txt = await f.async('text');
    return parseXml(txt);
  }
  async function readXmlOrCreate(zip, path, fallback){
    const f = zip.file(path); if(!f) return parseXml(fallback);
    const txt = await f.async('text'); return parseXml(txt);
  }
  async function writeXml(zip, path, xmlDoc){ zip.file(path, serialize(xmlDoc)); }
  function parseXml(s){
    const doc = new DOMParser().parseFromString(s,'application/xml');
    const err = doc.querySelector('parsererror'); if(err) throw new Error('XML parse error: '+(err.textContent||'unknown'));
    return doc;
  }
  function serialize(doc){ return new XMLSerializer().serializeToString(doc); }

  function bodyEl(doc){ return doc.getElementsByTagNameNS(NS.w,'body')[0]; }
  function lastSectPr(body){ const nodes = body?body.getElementsByTagNameNS(NS.w,'sectPr'):[]; return nodes && nodes.length? nodes[nodes.length-1] : null; }
  function descendants(node){ const out=[]; const w=document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, null); while(w.nextNode()) out.push(w.currentNode); return out; }
  function makePageBreak(doc){ const p=doc.createElementNS(NS.w,'w:p'); const r=doc.createElementNS(NS.w,'w:r'); const br=doc.createElementNS(NS.w,'w:br'); br.setAttributeNS(NS.w,'w:type','page'); r.appendChild(br); p.appendChild(r); return p; }

  function relsSkeleton(){ return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="${NS.pr}"></Relationships>`; }
  function numberingSkeleton(){ return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:numbering xmlns:w="${NS.w}"></w:numbering>`; }
  function stylesSkeleton(){ return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:styles xmlns:w="${NS.w}"></w:styles>`; }
  function footnotesSkeleton(){ return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:footnotes xmlns:w="${NS.w}"></w:footnotes>`; }
  function endnotesSkeleton(){ return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:endnotes xmlns:w="${NS.w}"></w:endnotes>`; }

  function makeRidAllocator(relXml){ return function(){ const list=relXml.getElementsByTagNameNS(NS.pr,'Relationship'); let max=0; for(const el of list){ const m=/rId(\d+)/.exec(el.getAttribute('Id')||''); if(m) max=Math.max(max,+m[1]); } return 'rId'+(max+1); } }

  function splitNameExt(path){ const i=path.lastIndexOf('.'); const ext=i>=0?path.substring(i+1).toLowerCase():''; return { name:i>=0?path.substring(0,i):path, ext } }
  function uniqueMediaName(zip, baseName, ext){ const folder='word/media/'; const base=baseName.substring(baseName.lastIndexOf('/')+1).replace(/[^A-Za-z0-9_\-]/g,'_'); let i=1,out; do{ out=`${folder}merged_${base}_${i}.${ext}`; i++; }while(zip.file(out)); return out; }
  function uniquePartPath(zip, srcFull){ const i=srcFull.lastIndexOf('.'); const ext=i>=0?srcFull.substring(i):''; const stem=i>=0?srcFull.substring(0,i):srcFull; let n=1,cand; do{ cand=`${stem}_merged_${n}${ext}`; n++; }while(zip.file(cand)); return cand; }
  function normalizePath(base, target){ const baseDir=base.substring(0,base.lastIndexOf('/')+1); const stack=(baseDir+target).split('/'); const out=[]; for(const seg of stack){ if(seg==='..') out.pop(); else if(seg==='.'||seg==='') continue; else out.push(seg);} return out.join('/'); }
  function canonicalizeMediaPath(p){ if(p.startsWith('word/media/')) return p; const idx=p.indexOf('word/'); if(idx>=0){ const rest=p.substring(idx+5); if(rest.startsWith('media/')) return 'word/'+rest; } return p; }
  function relativeTo(from,to){ const fromDir=from.substring(0,from.lastIndexOf('/')+1); return to.startsWith(fromDir)? to.substring(fromDir.length) : to; }

  function makeContentTypesEnsurer(ctXml){
    return function ensure(ext){
      const defaults = ctXml.getElementsByTagName('Default');
      for(const d of defaults){ if((d.getAttribute('Extension')||'').toLowerCase()===ext.toLowerCase()) return; }
      const map={ bmp:'image/bmp', gif:'image/gif', jpg:'image/jpeg', jpeg:'image/jpeg', png:'image/png', tif:'image/tiff', tiff:'image/tiff', emf:'image/x-emf', wmf:'image/x-wmf' };
      const d = ctXml.createElement('Default'); d.setAttribute('Extension', ext); d.setAttribute('ContentType', map[ext]||'application/octet-stream'); ctXml.documentElement.appendChild(d);
    }
  }

  // ========= Pattern search (paragraphs containing exact text) =========
  function findParagraphsContainingText(doc, text){
    const body = bodyEl(doc); const ps = Array.from(body.getElementsByTagNameNS(NS.w,'p'));
    const matches=[];
    for(const p of ps){
      let t='';
      const runs = p.getElementsByTagNameNS(NS.w,'t');
      for(const r of runs){ t += r.textContent; }
      if(t.includes(text)) matches.push(p);
    }
    return matches;
  }

  function triggerDownload(url, name){ const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1500); }
})();
</script>
</body>
</html>